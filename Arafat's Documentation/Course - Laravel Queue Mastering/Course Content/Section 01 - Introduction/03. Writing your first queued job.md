# **3. Writing Your First Queued Job**

Everything from the lecture is included with **zero missing details**, reorganized into clean sections.
Any additions I make are clearly marked as **(Added clarification: ‚Ä¶)**.

---

# **3. Writing Your First Queued Job ‚Äî Documentation**

## **Overview**

In this lesson, we create our first queue job and explore:

* How to generate a job using Artisan
* Job class structure
* Important traits: `ShouldQueue`, `Dispatchable`, `Queueable`, `SerializesModels`
* Passing models to jobs and serialization gotchas
* Behavior differences between queued vs synchronous jobs
* Handling large models, relations, binary data
* Unique jobs
* Encrypted jobs
* Job middleware (rate limiting, conditions)

This is one of the most critical lessons because it introduces all the ‚Äúgotchas‚Äù that need attention when writing
real-world queue jobs.

---

# **1. Generating a Job**

Laravel command to create a job:

```bash
php artisan make:job DailyEmails
```

Before running it, the instructor runs:

```bash
php artisan help make:job
```

This reveals useful options that developers often miss, including:

* Generate a Pest or PHPUnit test
* `--sync` option: creates a **synchronous** job (removes `ShouldQueue`)

Example:

```bash
php artisan make:job SyncExample --sync
```

Produces a class **without**:

* `implements ShouldQueue`
* `use Queueable`

Meaning: job will run immediately, even if the queue system is active.

(Added clarification: These synchronous jobs are useful for simple internal tasks but rarely used in production.)

---

# **2. Job File Location**

Jobs are stored in:

```
app/Jobs/
```

If the directory doesn‚Äôt exist, Laravel creates it automatically when you create your first job.

---

# **3. Job Class Structure (Queued Job)**

A queued job typically looks like:

```php
class DailyEmails implements ShouldQueue
{
    use Queueable; // inside that trait : use Dispatchable, InteractsWithQueue, SerializesModels;

    public function handle()
    {
        // work happens here
    }
}
```

### Breakdown of the parts:

### **3.1 `ShouldQueue`**

* Tells Laravel this job should be placed onto a queue.
* Without it ‚Üí job runs synchronously.

### **3.2 `Dispatchable`**

Provides the `dispatch()` method:

```php
DailyEmails::dispatch($user);
```

### **3.3 `InteractsWithQueue`**

Gives access to:

* job deletion
* job release
* job attempts
* failure handling


### **3.4 `SerializesModels`**

One of the **most important traits**.

It ensures Eloquent models passed into jobs are:

* Serialized correctly (stored in DB/Redis)
* Re-hydrated properly when job runs

The trait *serializes only the model identifier* (ID), not the full object. This avoids bloated payloads.


### **3.5 `Queueable`**


* uses the above traits internally

---

# **4. Passing Models to Jobs ‚Äî Critical Gotchas**

### **4.1 Problem: Full model is not stored**

Laravel stores only:

* Model class name
* Model ID

When job executes:

* The model is re-fetched from the database

Meaning relationships **are NOT serialized** unless manually loaded.

### **4.2 Collections behave differently**

Laravel **does NOT serialize relationships** inside Eloquent **collections**.

This is by design ‚Äî serializing huge relationship trees would be expensive.

---

# **5. Avoid Serializing Huge Models**

If a model contains heavy relationships or large data, you must **avoid passing the full model with loaded relationships
**.

Options:

---

## **5.1 Use "without relations" trick**

```php
$this->user = $user->withoutRelations();
```

This makes the serialized job lightweight and removes unnecessary data.

---

## **5.2 PHP 8 property promotion alternative**

In constructor:

```php
public function __construct(
    public User $user,
) {}
```

Then use:

```php
$user->withoutRelations();
```

Laravel internally transforms this into the same pattern as above.

(Added clarification: Property promotion does NOT auto-remove relations; you must manually do it. The lecture likely
implied using it *together* with `withoutRelations()`.)

---

## **5.3 Pass only IDs instead of models**

Best practice for large payloads:

```php
DailyEmails::dispatch($user->id);
```

And in the job:

```php
$user = User::find($this->userId);
```

---

# **6. Huge Payloads / Binary Data Gotcha**

Jobs are serialized as JSON.
Therefore:

* Binary data **must be encoded** (e.g., Base64)
* Objects that cannot be serialized cause job failure

Examples of problematic data:

* File contents
* Raw binary streams
* Large arrays from external APIs

Use `base64_encode()` or store the binary on disk and pass only a file path.

(Added clarification)

---

# **7. Writing Logic in `handle()` Method**

This is where job execution happens.

Example:

```php
public function handle()
{
    Mail::to($this->user->email)->send(new DailyEmailMailable());
}
```

You can also type-hint services (auto-injected via Laravel container):

```php
public function handle(ImageProcessor $processor)
{
    $processor->resize(...);
}
```

No need to manually instantiate:

```php
// NOT needed:
$processor = new ImageProcessor();
```

Laravel injects it automatically.

---

# **8. Unique Jobs**

Sometimes you need only **one copy** of a job to exist at a time.

Use:

```php
class DailyEmails implements ShouldQueue, ShouldBeUnique
```

This prevents duplicates from being queued.

Then define unique identifier:

```php
public function uniqueId()
{
    return $this->user->id;
}
```

Meaning:

* Only one DailyEmails job per user will be queued at a time.

### **8.1 Unique For Time Window**

```php
public $uniqueFor = 3600; // 1 hour
```

After this time ‚Üí job becomes "unlocked".

---

# **9. Encrypted Jobs**

For security-sensitive jobs:

```php
class DailyEmails implements ShouldQueue, ShouldBeEncrypted
```

This encrypts all serialized job data in:

* Database queue
* Redis queue

So if someone views the queue storage, job payload is unreadable.

---

# **10. Job Middleware**

Jobs can have middleware just like HTTP routes.

Add:

```php
public function middleware(): array
{
    return [
        new RateLimited('emails'),
    ];
}
```

Middleware use cases:

* Rate limiting
* Preventing simultaneous execution
* Blocking execution based on conditions
* Adding retries
* Logging

You can use middleware *instead of* or *in addition to* `ShouldBeUnique`.

(Added clarification: middleware is stackable and executes before/after the job‚Äôs `handle()`.)

---

# **11. Summary of All Gotchas Mentioned**

### **Model Gotchas**

* Models are re-fetched from DB; relationships not stored
* Collections do not serialize relations
* Use `withoutRelations()` when models are large
* Use IDs instead of models when possible

### **Serialization Gotchas**

* Binary data must be encoded
* Avoid putting heavy objects inside jobs

### **Job Behavior Gotchas**

* Use `ShouldBeUnique` to prevent duplicates
* Use `$uniqueFor` to enforce locks
* Use `ShouldBeEncrypted` for sensitive data
* Use middleware for rate limiting or conditional execution

## Extra

Here is **exactly what you asked for**:
A **clear, concrete, step-by-step example** showing *how Laravel actually handles a job with a model*, including
serialization, storage, and execution.
This demonstrates the concepts from ‚ÄúPassing Models to Jobs ‚Äî Critical Gotchas.‚Äù

---

# ‚úÖ **Full Example: How a Job With a Model Is Actually Handled**

We‚Äôll walk through this scenario:

> **You dispatch a job that sends a daily email to a user:**
>
> ```php
> DailyEmails::dispatch($user);
> ```

We will follow EXACT steps Laravel performs under the hood.

---

# **STEP 1 ‚Äî You Dispatch the Job**

```php
DailyEmails::dispatch($user);
```

Suppose `$user` is:

```php
User { 
    id: 5,
    name: "Ahmed",
    email: "ahmed@example.com",
    relations loaded: ['posts', 'comments', 'roles'] 
}
```

This model may be heavy.

---

# **STEP 2 ‚Äî Job Constructor Runs**

Inside your job:

```php
class DailyEmails implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(User $user)
    {
        $this->user = $user;
    }
}
```

Laravel now prepares to store this job in the queue.

---

# **STEP 3 ‚Äî SerializesModels Trait Activates**

`SerializesModels` changes `$this->user` into:

```php
[
    "class" => "App\Models\User",
    "id"    => 5,
]
```

‚ö†Ô∏è **Important:**
None of these are stored:

* name
* email
* phone
* loaded relationships (posts, comments, permissions)
* computed attributes
* appended values

Only **class + ID** is saved.

This is the reason why heavy models don‚Äôt break your queue storage.

---

# **STEP 4 ‚Äî Laravel Saves the Job to Queue Storage**

If using `database` connection:

A row in `jobs` table looks like:

```json
{
  "job": "Illuminate\Queue\CallQueuedHandler@call",
  "data": {
    "commandName": "App\\Jobs\\DailyEmails",
    "command": "O:16:\"App\\Jobs\\DailyEmails\":1:{s:4:\"user\";O:...}"
  }
}
```

If using Redis:

Stored as a JSON payload in a Redis list.

**Either way:**
The `user` property is NOT the full model ‚Äî only its ID.

---

# **STEP 5 ‚Äî Worker Picks Up the Job**

Worker runs:

```bash
php artisan queue:work
```

It pops the job off the queue and begins processing.

---

# **STEP 6 ‚Äî Laravel Re-Hydrates the Model**

Using the metadata saved earlier:

```php
$this->user = User::find(5);
```

This recreates a *fresh Eloquent model* from the database.

‚ö†Ô∏è **Meaning:**

* No loaded relationships exist anymore
* If user was deleted, this returns **null**
* If fields changed since dispatching, you get the new values

---

# **STEP 7 ‚Äî The Job Actually Executes (`handle`)**

```php
public function handle()
{
    Mail::to($this->user->email)->send(new DailyEmailMailable());
}
```

So the job runs with:

* `$this->user` reloaded fresh from database
* Access to relationships *only if you load them manually*

Example:

```php
$this->user->load('posts');
```

---

# **COMPLETE FLOW VISUALIZED**

```
You dispatch job ‚Üí Job stores only class + ID ‚Üí 
Stored in DB/Redis ‚Üí Worker reads job ‚Üí
SerializesModels restores model from DB ‚Üí 
Your handle() method runs.
```

---

# üß™ **Full Example Code With Debugging Prints**

### **Dispatch:**

```php
$user = User::with('posts')->find(5);

DailyEmails::dispatch($user);
```

### **Job:**

```php
class DailyEmails implements ShouldQueue
{
    use Dispatchable, Queueable, SerializesModels;

    public function __construct(public User $user) {}

    public function handle()
    {
        logger('User in handle: '.json_encode([
            'id' => $this->user->id,
            'loaded_relations' => array_keys($this->user->getRelations())
        ]));
    }
}
```

### **Logs Output:**

```
User in handle: {
    "id": 5,
    "loaded_relations": []
}
```

Notice:

* `posts` relation was **NOT** preserved
* Only ID was preserved and reloaded

---

# üß® Want to See Relationship Problems in Action?

Try dispatching:

```php
$user = User::with('roles.permissions')->find(5);
DailyEmails::dispatch($user);
```

Inside `handle`, check:

```php
dd($this->user->roles); // empty collection!
```

Because:

* Serialization removed all relations
* Worker loaded a **fresh user** without relationships
* You must load them manually:

```php
$this->user->load('roles.permissions');
```

---

# üéØ Perfect Real-World Example ‚Äî Avoiding Huge Model Serialization

Instead of:

```php
DailyEmails::dispatch($user);
```

Use:

```php
DailyEmails::dispatch($user->id);
```

Then:

```php
public function handle()
{
    $user = User::with('settings', 'preferences')->findOrFail($this->userId);

    // safe to process
}
```

This avoids all serialization issues.

---

# ‚úîÔ∏è Summary of the Example

| Step | What Happens                                    |
|------|-------------------------------------------------|
| 1    | You dispatch job with model                     |
| 2    | SerializesModels converts model into class + ID |
| 3    | Job saved to queue storage                      |
| 4    | Worker picks up the job                         |
| 5    | Laravel re-fetches model from DB                |
| 6    | Relationships are gone unless manually loaded   |
| 7    | `handle()` executes                             |

---


Perfect ‚Äî here are **both complete examples**, written clearly and practically, showing:

1Ô∏è‚É£ **How unique jobs work in the real world**
2Ô∏è‚É£ **How encrypted jobs work with real queue storage**

These examples are designed exactly like something you would put in your Laravel Queue Mastering documentation.

---

# **1. REAL-WORLD EXAMPLE: How Unique Jobs Work**

Scenario:

> You send daily summary emails to each user.
> You must ensure: **Only one job per user exists** in the queue ‚Äî no duplicates.

Without uniqueness, this could happen:

* Cron runs twice
* Or two controllers trigger the same email
* Or a user refreshes the page
* The result ‚Üí **user gets duplicate emails**

We fix this using **ShouldBeUnique**.

---

## **Step 1 ‚Äî Create the Job**

```php
php artisan make:job SendDailySummaryEmail
```

---

## **Step 2 ‚Äî Implement ShouldBeUnique**

```php
use Illuminate\Contracts\Queue\ShouldBeUnique;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Support\Facades\Mail;

class SendDailySummaryEmail implements ShouldQueue, ShouldBeUnique
{
    public function __construct(public int $userId) {}

    public function uniqueId(): string
    {
        // Only one job per user ID
        return 'daily-summary-'.$this->userId;
    }

    public $uniqueFor = 3600; // 1 hour lock

    public function handle()
    {
        $user = User::findOrFail($this->userId);

        Mail::to($user->email)->send(new DailySummaryMail($user));
    }
}
```

---

## **Step 3 ‚Äî Dispatching the Job**

```php
SendDailySummaryEmail::dispatch($user->id);
SendDailySummaryEmail::dispatch($user->id);
SendDailySummaryEmail::dispatch($user->id);
```

All 3 lines run ‚Üí but only **the first** job is stored.

Laravel will reject the duplicates because:

* The **unique key**: `daily-summary-5`
* Already exists in the queue or unique lock

---

## **Step 4 ‚Äî What Happens in the Queue Storage?**

### If using Redis (most common):

You will see a Redis key like:

```
laravel_unique_job:daily-summary-5
```

Its value might be:

```
1 (locked)
```

Once the job finishes OR after `$uniqueFor` time passes ‚Üí Laravel deletes that key.

---

## **Step 5 ‚Äî Real Execution Flow**

```
T=0 seconds: Job created ‚Üí unique key created
T=0-10 seconds: Worker picks job ‚Üí emails sent
T=10 seconds: Done ‚Üí key cleared
T=3600 seconds: If job still running or stuck ‚Üí lock auto expires
```

---

## **Diamond Summary (Quick Insight)**

| Problem                                       | Solution                      |
| --------------------------------------------- | ----------------------------- |
| Multiple jobs run per user ‚Üí duplicate emails | Use `ShouldBeUnique`          |
| Need only 1 job per time window               | Use `$uniqueFor`              |
| Unique per user                               | Set uniqueId based on user ID |
| Unique per type                               | Use static uniqueId           |

This is **production-grade uniqueness handling**.

---

# **2. REAL-WORLD EXAMPLE: Encrypted Jobs with Actual DB Payload**

This example shows how `ShouldBeEncrypted` protects sensitive data.

Scenario:

> You are queuing user payments.
> Payment data (card info, transaction tokens) must **not be visible** in plain text in the database.

---

## **Step 1 ‚Äî Create Job**

```bash
php artisan make:job ProcessPaymentJob
```

---

## **Step 2 ‚Äî Implement ShouldBeEncrypted**

```php
use Illuminate\Contracts\Queue\ShouldBeEncrypted;
use Illuminate\Contracts\Queue\ShouldQueue;

class ProcessPaymentJob implements ShouldQueue, ShouldBeEncrypted
{
    public function __construct(
        public int $userId,
        public string $cardToken,      // sensitive
        public float $amount,          // sensitive
        public array $metaData = []    // sensitive
    ) {}

    public function handle()
    {
        $user = User::findOrFail($this->userId);

        PaymentGateway::charge(
            user: $user,
            token: $this->cardToken,
            amount: $this->amount,
            metadata: $this->metaData
        );
    }
}
```

Important:
Laravel will encrypt ALL properties passed to the constructor.

---

## **Step 3 ‚Äî Dispatching the Job**

```php
ProcessPaymentJob::dispatch(
    userId: $user->id,
    cardToken: $token,
    amount: 199.99,
    metaData: ['ip' => request()->ip()]
);
```

---

## **Step 4 ‚Äî What Data Looks Like in Database Queue**

In `jobs` table, a normal job looks like:

```json
{
  "commandName": "App\\Jobs\\ProcessPaymentJob",
  "command": "{\"userId\":5,\"cardToken\":\"tok_123\",\"amount\":199.99,\"metaData\":{\"ip\":\"127.0.0.1\"}}"
}
```

A **non-encrypted job** is clearly readable.

---

But for an **encrypted job**, this becomes:

```json
{
  "commandName": "App\\Jobs\\ProcessPaymentJob",
  "command": "eyJpdiI6IkZHRl...ZFh1Q...d3c9PSIsInZhbHVlIjoiSVZNU..." 
}
```

This blob is:

* Base64
* AES-256-CBC encrypted
* Signed via Laravel security key (`APP_KEY`)

Nobody can read the card token or payment metadata.

---

## **Step 5 ‚Äî When Worker Runs**

Laravel does:

1. Decrypts the payload
2. Instantiates `ProcessPaymentJob`
3. Executes `handle()` normally

If decryption fails (wrong APP_KEY):

* Job fails automatically
* Sensitive data stays protected

---

## **Step 6 ‚Äî Security Summary**

| Feature                            | Benefit                               |
| ---------------------------------- | ------------------------------------- |
| Encrypted job payload              | No sensitive data visible in DB/Redis |
| Automatic decryption               | Worker receives clean PHP objects     |
| Compatible with all queue drivers  | Works with DB, Redis, SQS             |
| Zero code changes except interface | Extremely easy to use                 |

Perfect for:

* Payments
* API tokens
* Signed data
* Admin actions
* Logs containing identity data

---

# ‚úîÔ∏è Final Recap

You now have:

### **1Ô∏è‚É£ Unique Job:**

* Prevents duplicates
* Locks based on key
* Useful for daily emails, reports, sync tasks, user-specific jobs

### **2Ô∏è‚É£ Encrypted Job:**

* Protects sensitive payload
* Stores encrypted data in queues
* Safe for financial and confidential operations