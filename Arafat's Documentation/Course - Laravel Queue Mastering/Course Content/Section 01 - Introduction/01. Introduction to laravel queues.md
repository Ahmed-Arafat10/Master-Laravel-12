# **1. Introduction to Laravel Queues — Documentation**

## **Overview**

This lesson introduces Laravel Queues:

* Why queues are used
* How Laravel makes them available by default
* How to set up a Laravel project prepared for queue usage
* Why background jobs are essential for performance and user experience
* How tools like Sail, Docker, Redis, Supervisor, and Mailpit fit into queues development

---

## **1. What Are Laravel Queues?**

Laravel Queues allow you to push time-consuming tasks into the **background**, instead of executing them immediately during a web request.

Practical examples include:

* Sending emails
* Processing images
* Performing heavy calculations
* External API calls
* Logging operations
* Retrying failed operations

Using queues improves:

* **User experience** (quick response to actions)
* **Server performance**
* **Error handling** (jobs can be retried on failure)

---

## **2. Laravel Installation and Queue Support**

Laravel installations come with queue capabilities **pre-configured by default**.

* Every fresh Laravel project includes the queue system:

    * Queue configurations
    * Database migrations for failed jobs
    * Queue worker commands
    * Integration with Redis, Beanstalkd, SQS, etc.

### **Important Note: Lumen**

* Lumen technically supports queues, but is becoming obsolete.
* The instructor states Lumen is likely reaching end-of-life.
* Modern Laravel allows lightweight API-only builds, removing the need for Lumen.

**(Added clarification: Laravel now supports "light" installations using `--api` mode or modular setups, making Lumen unnecessary.)**

---

## **3. Creating a New Laravel Project**

The instructor uses the following commands:

### **Step 1: Create a Laravel project**

```bash
composer create-project laravel/laravel example-app
```

### **Step 2: Install Sail**

```bash
php artisan sail:install
```

What this does:

* Installs Laravel Sail into the project if not already present
* Allows you to choose:

    * MySQL
    * Redis
    * Mail server (Mailpit)
    * Etc.
* Pre-configures Docker environment for Laravel development

---

## **4. What Is Laravel Sail?**

Laravel Sail is a Docker-based **local development environment** for Laravel.

It allows developers to run:

* PHP
* MySQL
* Redis
* Mailpit
* Supervisor
* Queue workers
  …without installing them directly on your machine.

### Benefits:

* Reproduces a production-like environment
* Runs queue workers easily
* Allows monitoring queue operations
* Includes Supervisor inside Docker (important for queues)

---

## **5. Starting Sail**

After installation, you start the environment with:

```bash
./vendor/bin/sail up
```

This command:

* Starts all Docker containers:

    * App container
    * MySQL
    * Redis
    * Mailpit
    * Supervisor
* Loads Laravel's services so you can begin working immediately

---

## **6. Supervisor in Sail**

Supervisor is installed inside Sail automatically when chosen during setup.

* Supervisor manages queue workers.
* In development, it helps simulate real production queue processing.
* You can attach to the container to inspect real-time queue processing.

You will learn:

* How to view worker activity
* How to create **custom workers** inside the Sail environment
* How to configure Supervisor in production

**(Added clarification: Supervisor is commonly used in production because Laravel’s built-in `queue:work` command must always run in the background. Supervisor keeps it alive.)**

---

## **7. Mailpit (Mail Catcher)**

Mailpit is a development mail catcher:

* Shows emails sent by the application
* Prevents sending emails to real users during testing
* Provides a live inbox interface at a local URL

This is especially useful when:

* Testing email-sending jobs
* Evaluating user experience (UTX) when sending mail
* Debugging email content

The course will use Mailpit to demonstrate:

* How a user presses “Send email”
* Why queues improve the experience
* What happens if an email fails when not using queues

---

## **8. Why Queues Are Important (User Experience & Performance)**

### **1. User Experience**

When a user clicks a button (e.g., “Send Email”):

* They expect instant feedback
* A slow response creates frustration
* Queueing allows the application to respond immediately

Example:

* User clicks "Send Email"
* Application instantly returns: “Email is being sent…”
* Email actually sends in the background

### **2. Background Processing**

Time-consuming operations should never block user requests:

* Email sending
* Heavy processing
* Logging
* Integrations

### **3. Error Handling & Recovery**

If a synchronous operation fails:

* The user gets an error
* The operation is lost unless manually logged

If a queue job fails:

* Laravel stores the failure
* You can retry it
* You can inspect the exception
* You can track job attempts

**This is a major reason queues are widely used.**

---

## **9. Summary of Key Concepts**

### **Laravel Queues Provide:**

* Background job processing
* Faster user response times
* Better resource handling
* Automatic job retrying
* Separation between UI and backend tasks
* Development environment support via Sail
* Testing support via Mailpit
* Production reliability via Supervisor

---

## **10. Next Lesson**

The upcoming lesson covers:

* Queue-related terminology in Laravel
* Differences between:

    * **Queue**
    * **Job**
    * **Worker**
    * **Connection**
    * **Channel**
* And how Laravel structures these concepts