# **5. Dispatching Email With Photos (Example)**

## **Overview**

In this lesson, the instructor prepares the application for the first **real-world queued workflow**:

> A user uploads an image →
> A job processes that image →
> The job sends an email with the processed photo(s) attached.

This introduces the foundation for the upcoming image-processing pipeline and demonstrates how queues interact with Livewire, Mailables, and file uploads.

---

# **1. Setup Steps Completed Before the Lesson**

The instructor prepared the development environment ahead of time:

### **1.1 Ran:**

```bash
npm install
npm run dev
```

This compiles frontend assets using **Vite**.

### **1.2 Installed Laravel Breeze**

With:

* Alpine.js
* Livewire
  (Added clarification: Breeze installs Auth scaffolding and sets up the basic project UI.)

### **1.3 Restored an upload component**

* Breeze overwrote previous component files
* Instructor re-added the custom file-upload Livewire component
* This component handles:

    * Email input
    * Image file upload
    * Validation
    * Storing the uploaded file in `storage/app/photos`

These setup steps aren’t the focus of the course but are necessary for the demo.

---

# **2. Livewire Upload Component**

The component contains:

* Input for email
* Input for image
* Validation:

```php
'email' => 'required|email',
'photo' => 'required|image|max:1024', // max 1MB
```

After validation:

```php
$photoName = $this->photo->getClientOriginalName();
$this->photo->storeAs('photos', $photoName);
```

This stores the uploaded image at:

```
storage/app/photos/{filename}
```

Then the job is dispatched (shown later).

---

# **3. Creating the Image Processing Job**

Instructor runs:

```bash
php artisan make:job ImageProcessor
```

The old example job (`DailyEmails`) is deleted.

### **The new job will:**

* Receive the email of the user
* Receive the **photo filename**
* Build the file path inside the job
* Process the image
* Send the email with the processed image

---

# **4. Decision: Pass Path, Not Binary Data**

The instructor explains:

> The photo **could** be passed as base64 binary data — it would work because Laravel serializes job data.
> But this is inefficient for large images.

Therefore, **the job receives only the filename**:

```php
public function __construct(public string $email, public string $photoName) {}
```

Inside the job:

```php
public string $filePath;

public function __construct($email, $photoName)
{
    $this->email = $email;
    $this->photoName = $photoName;
    $this->filePath = storage_path('app/photos/' . $photoName);
}
```

(Added clarification: This avoids heavy job payloads and speeds up serialization.)

---

# **5. Dispatching the Job From Livewire**

Inside the Livewire component:

```php
ImageProcessor::dispatch($this->email, $photoName);
```

Because the queue driver is still `sync`:

* The job executes immediately
* Execution is visible in the Livewire request cycle

This proves dispatching works.

---

# **6. Verifying the File Path**

The instructor does:

```php
dd($this->filePath);
```

When submitting the form, output shows:

```
storage/app/photos/{filename}
```

So file storage + path resolution works correctly.

---

# **7. Creating the Email (Mailable)**

Instructor executes:

```bash
php artisan make:mail SendUserPhotos
```

This creates:

```
app/Mail/SendUserPhotos.php
```

The instructor prepares the Mailable to:

* Accept file path
* Attach the file
* Send simple text or view content

---

# **8. Attaching the Photo to the Email**

Inside the job:

```php
Mail::to($this->email)->send(
    (new SendUserPhotos($this->filePath))
        ->attach($this->filePath)
);
```

The instructor also assigns it to a variable for readability:

```php
$mail = new SendUserPhotos($this->filePath);
$mail->attach($this->filePath);

Mail::to($this->email)->send($mail);
```

---

# **9. Handling the Mailable View**

At first, Laravel throws:

> “View not found”

Because Breeze didn't create a matching view automatically.
So the instructor creates a simple Blade file:

### `resources/views/welcome_email.blade.php`

```html
Hello,
These are your images generated on our server.
```

Then in the Mailable:

```php
public function build()
{
    return $this->view('welcome_email');
}
```

Now the email has:

* The view content
* The attached uploaded image

---

# **10. Testing With Mailpit**

Since Sail already installed Mailpit (from earlier lessons):

* Instructor sends the email from the form
* Mailpit shows the received email with attachment
* Everything works end-to-end

This confirms:

* File upload
* Livewire validation
* File storage
* Job dispatch
* Mailable
* Attachment
* Sending email
* Mailpit catching the email

All operate correctly.

---

# **11. Adding Redirect After Success**

After sending the email, the instructor adds a redirect in the Livewire component:

```php
return redirect()->back();
```

This refreshes the form and keeps UX clean.

---

# **Summary of What You Learned**

### ✔ Uploading file via Livewire

### ✔ Validating email + photo

### ✔ Storing image in `storage/app/photos`

### ✔ Creating a queued job (`ImageProcessor`)

### ✔ Passing filename, not binary data

### ✔ Resolving file path inside job

### ✔ Creating a custom Mailable (`SendUserPhotos`)

### ✔ Attaching image in the email

### ✔ Testing with Mailpit

### ✔ Understanding synchronous queue execution

### ✔ Preparing for async job processing (next lessons)