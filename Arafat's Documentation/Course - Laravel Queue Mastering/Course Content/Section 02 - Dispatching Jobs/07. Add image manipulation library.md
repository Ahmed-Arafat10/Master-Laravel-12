# 7. Add Image Manipulation Library — Documentation

## Overview

This lesson prepares the app for real image processing by installing an image-manipulation library and wiring it into the existing job flow.
Goals covered in the lecture:

* Add a PHP image library (works with GD or Imagick)
* Use the library inside the job to resize/save/encode images
* Keep job payloads small (pass filename, not binary)
* Plan to split processing into 2–3 background jobs and run a final dependent job to send the email
* Handle Docker / Sail restarts if containers hang during install

Any extra suggestions or missing implementation patterns I add are clearly marked as **(Added clarification: …)**.

---

# Install image library

### Steps shown in lecture

1. Use Composer to require an image package:

   ```bash
   composer require <image-package>
   ```

   (Instructor ran `composer require` and the package installed successfully.)

2. The package chosen works with either **GD** or **Imagick** kernel; the instructor expects GD is already present in Sail. If GD is missing, the instructor would add it to the Docker container.

**(Added clarification: I didn’t see the exact package name in the transcript. Common choices are `intervention/image` and `spatie/image`. Below I provide examples for both so you can pick what fits your project.)**

---

# Ensure PHP image extension is available (GD or Imagick)

* The chosen PHP package relies on a PHP image extension (GD or Imagick). In Laravel Sail you usually have GD pre-installed, but if not you must add it to the container image and rebuild Sail.

**Example (if using Sail + PHP with GD):**

* Add GD to the Dockerfile or the Docker image used by Sail, then rebuild containers:

  ```dockerfile
  # in Dockerfile: example for Debian-based PHP
  RUN apt-get update && apt-get install -y libgd-dev \
      && docker-php-ext-configure gd --with-jpeg --with-freetype \
      && docker-php-ext-install gd
  ```

  Then:

  ```bash
  ./vendor/bin/sail build --no-cache
  ./vendor/bin/sail up -d
  ```

**(Added clarification: exact package names and Docker commands depend on the base image. If you use `sail` official images, there are examples in Laravel Sail docs. If you need, I can provide a ready-to-use Sail Dockerfile snippet for GD or Imagick.)**

---

# Use the library inside your job (typical patterns)

Below are two concrete examples (one for **Intervention Image**, one for **Spatie Image**). Use whichever package you installed.

---

### Example A — Intervention Image (very common)

**Install**

```bash
composer require intervention/image
```

**In your job (`app/Jobs/ImageProcessor.php`)**

```php
use Intervention\Image\ImageManagerStatic as Image;

public function handle()
{
    $sourcePath = storage_path('app/photos/' . $this->photoName);

    // open image
    $img = Image::make($sourcePath);

    // create sizes
    $thumbPath = storage_path('app/photos/thumb_' . $this->photoName);
    $mediumPath = storage_path('app/photos/medium_' . $this->photoName);
    $largePath = storage_path('app/photos/large_' . $this->photoName);

    $img->resize(150, null, function ($constraint) {
        $constraint->aspectRatio();
        $constraint->upsize();
    })->save($thumbPath);

    $img->resize(600, null, function ($constraint) {
        $constraint->aspectRatio();
        $constraint->upsize();
    })->save($mediumPath);

    $img->resize(1200, null, function ($constraint) {
        $constraint->aspectRatio();
        $constraint->upsize();
    })->save($largePath);

    // continue: dispatch final job to send email, or attach and mail directly
}
```

**(Added clarification: Intervention uses GD or Imagick as backend automatically. Use `Image::make()` to load and `save()` to write. Intervention modifies the image instance, so re-open source if needed for independent sizes.)**

---

# Keep job payloads small

* Pass only the **filename** (or `storage` path), not the binary image content.
* Inside the job, compute the full path with `storage_path('app/photos/' . $this->photoName)` and operate on the file system.

(This is exactly what the instructor did.)

---

# Splitting processing into multiple jobs & orchestrating completion

The instructor said they will split image processing into 2–3 jobs (each job creates one size) and then have a final job run **after** all processing jobs finish to send the email. There are two common orchestration approaches:

### 1) `Bus::batch` (recommended for parallel jobs + final callback)

Use Laravel’s Bus batching to dispatch jobs in parallel and attach `then()` to run when all succeed.

```php
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
use Throwable;

$batch = Bus::batch([
    new CreateThumbnail($this->photoName),
    new CreateMedium($this->photoName),
    new CreateLarge($this->photoName),
])->then(function (Batch $batch) {
    // All jobs completed successfully — now dispatch the email job
    SendUserPhotos::dispatch($this->email, $this->photoName);
})->catch(function (Batch $batch, Throwable $e) {
    // Handle failures
})->dispatch();
```

**(Added clarification: `Bus::batch` requires queue driver support that persists batches — works with database and Redis drivers. Horizon provides a UI for batches.)**

### 2) Chaining with `then()` (if you want sequential)

Use `Bus::chain()` to run jobs sequentially (not parallel):

```php
Bus::chain([
    new CreateThumbnail($this->photoName),
    new CreateMedium($this->photoName),
    new CreateLarge($this->photoName),
    new SendUserPhotos($this->email, $this->photoName)
])->dispatch();
```

**(Added clarification: chain is sequential; batch is parallel with a final callback.)**

---

# Job design suggestions (from lecture + best practices)

* Each size job should:

    * Accept only `$photoName` (and maybe a target path)
    * Build the storage path inside `handle()`
    * Create and persist the resized file
    * Mark success/failure (the queue system handles retries/failures)

* Final job (mailer) should:

    * Wait until resized files exist (guaranteed if you use `Bus::batch` then-callback)
    * Collect processed file paths and attach them to a mailable
    * Send via Mailpit / SMTP

**(Added clarification: consider storing generated filenames or paths in a lightweight DB record (e.g., `photo_processing` table) so the final job can reliably get all generated assets even if the worker crashes and retries. This increases reliability.)**

---

# Handling failures & retries

* Set reasonable `tries` and `timeout` on your jobs:

  ```php
  public $tries = 3;
  public $timeout = 120;
  ```
* Use `failed()` method on jobs to log failures and alert (or mark DB record).
* For batch jobs, use `catch()` callback to run recovery logic.

---

# Quick check-list (what to do now)

1. `composer require intervention/image` (or your chosen package)
2. Ensure GD or Imagick is present in container (add to Dockerfile and rebuild if needed)
3. Update `ImageProcessor` job to resize using the chosen package (code examples above)
4. Split processing into per-size jobs (CreateThumbnail, CreateMedium, CreateLarge)
5. Orchestrate with `Bus::batch()` and dispatch final `SendUserPhotos` in `then()`
6. Set job `tries`, `timeout` and implement `failed()` handlers
7. Test locally with `QUEUE_CONNECTION=sync` first, then switch to Redis/DB and run queue workers:

   ```bash
   ./vendor/bin/sail up -d
   ./vendor/bin/sail artisan queue:work
   ```
8. Use Mailpit to inspect emails and attachments