# **12. Job Batching – Part 1**

This lesson introduces **Job Batching**, how it differs from job chaining, and how Laravel handles parallelized background work. The instructor also demonstrates how to configure batches, how to track completion, and important rules such as not serializing closures that reference `$this`.

---

# **1. Recap: Chaining vs. Batching**

## ✔ Job Chaining

* Jobs run **strictly in order**
* Next job is NOT queued until the previous job finishes
* Used when the order is critical
* Runs on *one queue*, sequentially
* If ANY job fails → the whole chain stops
* Good for:

    * Resize → Optimize → Upload → Email
    * Steps that depend on each other

## ✔ Job Batching (NEW CONCEPT)

* Jobs run **in parallel**
* Order is **NOT guaranteed**
* Laravel dispatches all jobs immediately (fan-out)
* Works best when you have multiple workers
* Perfect for CPU-heavy / IO-heavy work
* Good for:

    * Processing 100 thumbnails
    * Running antivirus scans
    * Generating reports for many users
    * Anything parallelizable

### **Key differences:**

| Feature             | Chaining              | Batching               |
| ------------------- | --------------------- | ---------------------- |
| Order guaranteed    | ✔ Yes                 | ✖ No                   |
| Parallel processing | ✖ No                  | ✔ Yes                  |
| Stops if any fail   | ✔ Yes                 | ✖ Not automatically    |
| Use-case            | Sequential operations | Heavy tasks, many jobs |

(Added clarification: You can manually stop a batch early using middleware & batch cancellation.)

---

# **2. When to Use Job Batching**

Use batching when you:

* Want to execute many similar jobs at the same time
* Do NOT care about order
* Want to fully utilize parallel workers
* Want a callback executed when **ALL** jobs finish
* Want to track progress (`total`, `pending`, `failed`, `processed`)

**Typical example from course:**
Processing image sizes **in parallel** (500px, 600px, 700px, …) and then performing an action *after* all finish.

---

# **3. Requirements: Batch Table Migration**

Laravel needs a special database table to track batch progress.

Run:

```
php artisan queue:batches-table
```

Or in Sail:

```
./vendor/bin/sail artisan queue:batches-table
```

Then migrate:

```
./vendor/bin/sail artisan migrate
```

This creates:

* `job_batches` table
  Used to track:
* batch UUID
* total jobs, failed jobs
* finished/failed timestamps
* completion statuses

(Added clarification: Batching **requires** database tracking. Redis alone isn't enough.)

---

# **4. Creating a Job Batch**

Laravel batching uses `Bus::batch()`:

```php
Bus::batch([
    new ImageResize($file, 500),
    new ImageResize($file, 600),
    new ImageResize($file, 700),
])->then(function (Batch $batch) {
    // Runs when ALL jobs succeed
})->dispatch();
```

### **Notes**

* All jobs are dispatched **immediately**
* All jobs run on **same queue** unless overridden
* Any worker can pick any job
* Execution order is random

---

# **5. Adding "completion" callback**

`->then()` executes **after all jobs finish successfully**:

```php
->then(function (Batch $batch) use ($email, $fileOutput) {
    // Send final email with attachments
})
```

### What this callback gives you:

* It's executed ONLY after the batch is 100% completed
* You can check batch properties:

```php
$batch->totalJobs;
$batch->failedJobs;
$batch->finished();
```

(Added clarification: You cannot use `$this` inside the closure because closures must be serializable.)

---

# **6. Fixing Errors: You Cannot Use `$this` Inside Batch Closures**

The instructor encountered:

```
Serialization of 'TemporaryUploadedFile' is not allowed.
```

Why?

Because inside the `then()` closure, he used:

```php
use ($this)
```

Closures inside batches must be serialized, but `$this` may contain:

* Livewire temporary uploaded files
* File objects
* Image managers
* Resources
* Or ANY non-serializable data

**Fix:** pass only scalars (strings, arrays):

```php
->then(function () use ($email) {
    // this works
});
```

---

# **7. Making Jobs "Batch-Aware": The `Batchable` Trait**

Laravel requires jobs in a batch to use:

```php
use Illuminate\Bus\Batchable;
```

Your job class must include:

```php
class ImageResize implements ShouldQueue
{
    use Batchable;
}
```

### Why?

Because `Batchable` adds:

* `$this->batch()` reference
* Ability to detect if batch was cancelled
* Ability to abort early:

```php
if ($this->batch()->cancelled()) {
    return;
}
```

---

# **8. Running Batch Jobs From Another Job**

The instructor realized batching **may fail** when initiated from inside another queued job.

Reason:

Some batching operations require access to the **current request lifecycle** or a location outside job context.

(Added clarification: Batching works fine anywhere, but closures must not reference `$this`, and you must ensure data inside closure is serializable.)

Fix used by instructor:

* Removed references to `$this`
* Passed variables explicitly into `use(...)` of the closure
* Ensured closures only contain primitive serializable values
* Ensured all batch jobs use `Batchable`

After fixing → batching worked correctly.

---

# **9. Error Demonstrations and Fixes**

## Problem 1: Missing `Batchable`

Symptoms: Batch does not run / errors during dispatch.

Fix:

```php
use Batchable;
```

## Problem 2: Using `$this` in callback

Symptoms:

```
Serialization of 'TemporaryUploadedFile' is not allowed.
```

Fix: Replace

```php
->then(function () use ($this) { ... })
```

With

```php
->then(function () use ($email, $fileOutput) { ... })
```

## Problem 3: Using PHP artisan instead of Sail

Running:

```
php artisan migrate
```

fails because local environment cannot reach Docker MySQL.

Fix:

```
./vendor/bin/sail artisan migrate
```

---

# **10. Batching Example from the Lesson**

### Complete Example (cleaned):

```php
Bus::batch([
    new ImageResize($fileName, 500),
    new ImageResize($fileName, 600),
    new ImageResize($fileName, 700)
])
->then(function () use ($email, $fileOutputPath) {
    SendUserEmail::dispatch($email, $fileOutputPath, [500,600,700]);
})
->dispatch();
```

### How it behaves:

1. Laravel pushes all three ImageResize jobs immediately
2. Workers pick them in *any* order
3. When all 3 finish successfully
4. The `then()` callback runs
5. Callback dispatches `SendUserEmail` job
6. Email job runs last