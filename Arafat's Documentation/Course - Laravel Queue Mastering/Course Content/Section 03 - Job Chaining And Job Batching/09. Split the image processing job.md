# **9. Splitting the Image Processing Job**

## **Overview**

In this lesson, the instructor:

* Demonstrates why **heavy logic must NOT be placed inside job constructors**
* Shows the common **serialization exception** that happens when putting objects in constructors
* Explains how to split a large job into **multiple smaller, dedicated jobs**
* Begins preparation for **parallel processing** of image resizes
* Tests extraction of the resizing logic into a new `ImageResize` job
* Confirms the image processing logic now works in isolation

The next lecture will use **Laravel batch jobs** to run the resizing jobs in **parallel** and then run a final job that sends an email with all processed images.

---

# **1. Why Job Constructors Must Stay Simple**

Laravel queue jobs must serialize their properties when queued.
If you put a **complex object** (image driver, image instance, file handle, manager, etc.) in the constructor, Laravel throws an exception:

### **Example shown in lecture:**

```php
public function __construct()
{
    $manager = new ImageManager();
    $this->img = $manager->read($path);
}
```

This results in:

```
SerializationException: Unable to serialize payload
```

Laravel tries to serialize the job **before** putting it on the queue.
Objects like:

* GD resources
* Image objects
* Closures
* File handles
* External library objects

are **not serializable**, causing the crash.

### **Correct pattern:**

* Constructor = **only strings, ints, IDs**
* Heavy logic = **inside handle()**

Example:

```php
public function __construct(
    public string $fileName,
    public int $size
) {}

public function handle()
{
    // Heavy image manipulation goes here
}
```

(Added clarification: The entire queue system relies on serializing only primitive values. Objects are recreated during job execution.)

---

# **2. Reminder: Jobs Can Also Run From Scheduler (Kernel)**

Before splitting jobs, the instructor briefly reminds:

* Queue jobs can be triggered on schedule using Laravel’s Task Scheduler.

Example:

```php
use App\Jobs\Heartbeat;
use Illuminate\Support\Facades\Schedule;

Schedule::job(new Heartbeat)->everyFiveMinutes();
```

So queues support:

* Manual dispatch (`dispatch()`)
* Auto-dispatch via scheduler
* Chained jobs
* Batch jobs (parallel)

---

# **3. Splitting the Large Job Into Smaller Jobs**

The existing “image processing + send email” job is too big.

Instructor splits it into:

### **1. `ImageResize` job**

* Accepts:

    * `$fileName`
    * `$size`
* Creates resized images
* Saves them into `storage/app/photos/output/`

### **2. `ImageResizeAndSendEmail` job**

* (Will be used later as the orchestrator)
* Will dispatch multiple resize jobs
* Will later dispatch the email job
* Not fully used yet in this lecture

#### Creation of jobs:

```bash
php artisan make:job ImageResize
php artisan make:job ImageResizeAndSendEmail
```

But the email-sending part remains in the main job for now until batching is implemented.

---

# **4. Building the ImageResize Job**

Inside `ImageResize`:

### **Constructor**

```php
public function __construct(
    public string $fileName,
    public int $size
) {}
```

### **Handle method**

* Build `$filePath`
* Build `$attachmentPath`
* Extract filename (remove extension) using `pathinfo()`
* Save resized version as JPEG
* Final name format:

```
{filename}_{size}.jpeg
```

### Example path build:

```php
$info = pathinfo($this->fileName);
$nameOnly = $info['filename'];

$outputFile = $attachmentPath . $nameOnly . '_' . $this->size . '.jpeg';
```

### Example save operation:

```php
$manager = new ImageManager();
$image = $manager->read($filePath);
$resized = $image->scale($this->size);
$resized->save($outputFile, format: 'jpeg');
```

(Added clarification: `scale()` preserves aspect ratio, which fixed previous distortion issues.)

---

# **5. Dispatching Multiple Resize Jobs (Manually for Now)**

To test, instructor dispatches sequential jobs:

```php
ImageResize::dispatch($this->photoName, 100);
ImageResize::dispatch($this->photoName, 500);
ImageResize::dispatch($this->photoName, 600);
ImageResize::dispatch($this->photoName, 700);
```

Right now they run **synchronously** because the queue connection is still `sync`.

In later lessons, they will:

* Use Redis
* Run queue:work
* Convert these into **parallel background jobs**

---

# **6. Debugging: Missing Files and Incorrect Paths**

Instructor encountered multiple issues:

### **Errors:**

* “Unable to decode input”
* “Unable to open path”
* Missing resized files
* Wrong filenames being saved
* Files overwritten due to identical output names

### **Root causes:**

* File saved to wrong directory
* JPEG suffix duplicated incorrectly
* Forgot to add `-{size}` to filename
* Reading from wrong path variable
* Missing `this->` before property names
* Missing file extension removal

### **Final fix:**

* Use `pathinfo()` properly
* Use correct `$attachmentPath`
* Add `_{size}.jpeg` suffix
* Use absolute path from `storage_path()`
* Save to `output/` directory

When corrected, generated files were:

```
mini_course_100.jpeg
mini_course_500.jpeg
mini_course_600.jpeg
mini_course_700.jpeg
```

All working.

---

# **7. Performance Demonstration**

The instructor highlights:

* Even on a local machine, resizing 3–4 images took ~1 second
* In real-world:

    * Larger images = more CPU time
    * Production queues run on remote workers
    * Network latency increases email-sending time

This reinforces why **queues are mandatory** for media-heavy operations.

(Added clarification: In modern apps, resizing is CPU-heavy, so jobs should run on background workers with auto-scaling.)

---

# **8. Preparing for Next Lecture: Parallel Processing with Dependencies**

In this lecture, the split was:

* **Primary job** → dispatches resize jobs
* **ImageResize job** → handles resizing

Next lecture will introduce:

* **Laravel Batch Jobs**
* Running all resize jobs in parallel
* A final job that:

    * Waits for all resizers to finish
    * Reads the generated files
    * Sends email with all attachments

This will be the full asynchronous pipeline.