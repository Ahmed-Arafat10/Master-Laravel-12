# **11. Job Chaining – Part 2**

This lesson continues from Part 1 and shows how to implement job chaining **correctly and safely** in Laravel, especially for the image-processing workflow:

* Resize image to multiple sizes
* When all resizing jobs finish, send a final email containing all attachments

Laravel's `Bus::chain()` is used to guarantee ordering with **zero race conditions** even when using multiple workers.

---

# **1. Using the Bus Facade to Chain Jobs**

Laravel’s job chaining is accomplished using:

```php
Bus::chain([...])->dispatch();
```

The instructor notes:

* The chain expects an **array** or **collection** of job instances.
* All jobs run **in strict order**.
* You may assign connection/queue on the entire chain:

```php
Bus::chain([
    new ImageResize($file, 300),
    new ImageResize($file, 600),
    new ImageResize($file, 700),
])->onQueue('default')->dispatch();
```

---

# **2. The Original Problem: Knowing When All Jobs Finished**

The instructor highlights a common issue:

If you try to send the email **inside the controller** after dispatching the resize jobs:

```php
ImageResize::dispatch(...);
ImageResize::dispatch(...);
ImageResize::dispatch(...);

Mail::to($email)->send(...);
```

This breaks as soon as:

* You use Redis/Database queue (async)
* You have multiple workers
* Jobs run in parallel

The email may be sent before image processing finishes.

---

# **3. Attempted Fix #1: Put email-sending mailable on the same queue**

The idea:

```php
SendUserPhoto::dispatch(...)
    ->onQueue('send_mail');
```

If all resize jobs also use `'send_mail'` queue, maybe order is preserved.

**BUT:**
With multiple workers, this can still cause:

* Email job being picked up early
* Email job running before resizing jobs finish

So this approach is **not guaranteed**.

---

# **4. The Correct Fix: Make Email Sending Its Own Chained Job**

The instructor creates a dedicated job:

```
SendUserEmail
```

Advantages:

### ✔ Runs only when previous jobs succeeded

### ✔ Guaranteed order

### ✔ No race conditions

### ✔ Works with any number of workers

### ✔ Clean separation of responsibilities

### ✔ Fully queued (not executed in controller)

---

# **5. Creating the `SendUserEmail` Job**

The job needs:

* `email` (address to send to)
* `fileOutputPath` (base path where resized images are stored)
* `sizes` (array of sizes that were generated, e.g. `[500,600,700]`)

```php
class SendUserEmail implements ShouldQueue
{
    public function __construct(
        public string $email,
        public string $fileOutputPath,
        public array $sizes
    ) {}

    public function handle()
    {
        $mailable = new SendUserPhoto();

        foreach ($this->sizes as $size) {
            $mailable->attach(
                $this->fileOutputPath . "{$size}.jpg"
            );
        }

        Mail::to($this->email)->send($mailable);
    }
}
```

(Added clarification: This job is queued, so mail sending now happens fully in the background.)

---

# **6. Building the Chain Dynamically**

Instead of manually writing each job:

```php
[
    new ImageResize($file, 500),
    new ImageResize($file, 600),
    new ImageResize($file, 700),
]
```

You can build it programmatically:

```php
$sizes = [500, 600, 700];

$jobs = [];

foreach ($sizes as $size) {
    $jobs[] = new ImageResize($fileName, $size);
}

$jobs[] = new SendUserEmail($email, $fileOutputPath, $sizes);

Bus::chain($jobs)->dispatch();
```

Benefits:

* No hardcoded job count
* Adding/removing image sizes becomes trivial
* Jobs will run properly even if you add 10, 20, or 100 resizes

---

# **7. Guaranteed Job Order**

Because of chaining:

```
[Job1: Resize 500]
       ↓
[Job2: Resize 600]
       ↓
[Job3: Resize 700]
       ↓
[Job4: Send Email with all attachments]
```

You are **100% guaranteed**:

* Email job will never run early
* Resizing is always fully completed
* Workers do not interfere with order
* Chain stops if any job fails

---

# **8. Chaining Closures Instead of Jobs**

Laravel also supports:

```php
Bus::chain([
    new ImageResize(...),
    function () {
        Log::info("Images processed!");
    },
    new SendUserEmail(...)
])->dispatch();
```

(Added clarification: Closures work only if they don’t capture unserializable variables. Avoid capturing large objects, resources, or models-with-relations.)

---

# **9. Notes About Error Handling**

If any job in the chain fails:

### ✔ The chain stops

### ✔ Remaining jobs are **never** queued

### ✔ You can detect the failure using `catch()` in Laravel 10+

Example:

```php
Bus::chain([...])
    ->catch(function (Throwable $e) {
        Log::error('Chain failed: ' . $e->getMessage());
    })
    ->dispatch();
```

(Added clarification: You cannot continue the chain after a caught failure — the chain is considered broken.)

The instructor will test this later after migrating failed jobs table.

---

# **10. Final Testing Results (from lesson)**

The instructor successfully tested:

* Images resized: 500px, 600px, 700px
* Job chain executed in correct order
* Email job last, with all attachments included
* Email delivered via Mailpit
* Works even with multiple jobs and multiple workers

---

# **11. What’s Next**

In the next lessons:

* Take a Word document
* Add a signature watermark
* Convert it to PDF (using LibreOffice)
* Use job chaining and/or batching to handle high time-cost operations

(Added clarification: PDF conversion is computationally expensive → perfect for background job pipelines.)