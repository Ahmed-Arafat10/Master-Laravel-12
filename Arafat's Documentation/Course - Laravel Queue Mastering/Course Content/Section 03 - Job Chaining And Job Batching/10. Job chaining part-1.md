# **10. Job Chaining â€“ Part 1**

## **Overview**

This lesson introduces **Job Chaining** in Laravel â€” a mechanism that ensures multiple jobs run **in a specific order**, one after the other, *regardless of queue priorities, queue types, or number of workers*.

The lecture explains:

* Why chaining exists
* Problems with race conditions when sequencing jobs manually
* Why constructors cannot contain heavy objects
* How â€œShouldBeEncryptedâ€ works internally
* How to use chaining to guarantee job order
* Why try/catch CANNOT catch worker failures
* Why running multiple workers breaks naive "order-based" dispatching

This prepares the ground for job-chaining implementation in the next lesson.

---

# **1. Final Note on ShouldBeEncrypted (additional use case)**

The instructor recalls an additional use case for the `ShouldBeEncrypted` interface.

Laravel supports:

```php
class MyJob implements ShouldQueue, ShouldBeEncrypted
```

### What actually happens internally?

Laravel:

1. **Clones the job**
2. **Serializes the clone**
3. **Encrypts the serialized payload**
4. Saves encrypted data inside database/Redis

Because encryption and storage are separated, you can meet security compliance requirements such as:

* **PCI-DSS (payment card industry)**
* **HIPAA**
* **SOC2**

This ensures sensitive payloads are **invisible** to database administrators or attackers.

(Added clarification: ShouldBeEncrypted encrypts job payloads using Laravelâ€™s `Encryptor`, the same class used for encrypted cookies.)

---

# **2. Why Job Chaining Exists**

Chaining solves a fundamental problem:
**When a series of jobs must execute in a strict order.**

Example:

```
ResizeLargeImage â†’ OptimizeImage â†’ UploadToS3 â†’ SendEmailToUser
```

Without chaining, these problems occur:

---

## **Problem 1: Synchronous dispatch only works on sync queue**

When queue driver = `sync`, these jobs run sequentially:

```php
JobA::dispatch();
JobB::dispatch();
JobC::dispatch();
```

But once you switch to Redis/Database queue â†’ order is **NOT guaranteed**.

Why?

---

## **Problem 2: Queue priorities break your order**

Example:

```php
JobA::dispatch()->onQueue('low');
JobB::dispatch()->onQueue('high');
```

Even though JobA appears first in your code, JobB will run **first** because high-priority workers pick it up immediately.

---

## **Problem 3: Multiple workers create race conditions**

Even on *the same queue*, running multiple workers:

```
Worker #1 â†’ picks JobA  
Worker #2 â†’ picks JobB  
```

JobB may finish first, regardless of dispatch order.

This breaks systems requiring order-dependent operations:

* Step 1 must finish before Step 2
* A record must be created before updating it
* A file must be prepared before emailing it
* A video must be transcoded before generating its thumbnail

---

# **3. Why naive methods fail**

### Method A â€” Putting jobs on the same queue

Fails when:

* There are multiple workers
* Or high/low queue priorities
* Or delays / retries occur

### Method B â€” Using `ShouldBeUnique`

Only ensures **one job at a time**, but cannot enforce **order**.

### Method C â€” try/catch

Does NOT work with async jobs:

```php
try {
    JobA::dispatch();
    JobB::dispatch();
} catch (\Exception $e) {}
```

This try/catch is **useless** because once the job is dispatched, execution moves to the queue worker â€” NOT inside your try block.

(Added clarification: Exceptions inside a job never bubble back to the controller.)

---

# **4. Solution: Job Chaining**

Laravel gives first-class support for job sequences:

```php
Bus::chain([
    new JobA(),
    new JobB(),
    new JobC(),
])->dispatch();
```

This guarantees:

### âœ” JobA runs

### âœ” Only when JobA succeeds â†’ JobB runs

### âœ” Only when JobB succeeds â†’ JobC runs

### âœ” If any job fails â†’ the chain stops

### âœ” Order is preserved regardless of queue priorities

### âœ” Order is preserved even with multiple workers

---

# **5. Important Notes About Failures in Chains**

* If **any** job in the chain fails â†’ the entire chain stops
* You can optionally define a `failed($exception)` method inside each job
* You CANNOT catch job failures in a controller using try/catch
* You CAN add retry attempts per job

Example:

```php
public $tries = 3;

public function failed(Throwable $e)
{
    Log::error('Job failed', ['error' => $e->getMessage()]);
}
```

---

# **6. Demonstration of Serialization Error (Important)**

The instructor shows a developer mistake:

Putting the image-resizing logic **in the constructor**:

```php
public function __construct() {
    $this->manager = new ImageManager();
    $this->img = $this->manager->read($path);
}
```

This throws an immediate serialization exception:

```
SerializationException: Unable to serialize payload
```

### Why?

* Job constructors must contain **only basic data types**
* File handles, GD resources, image objects, and closures cannot be serialized
* This is why all **heavy work must live inside `handle()`**

(Added clarification: If you put a non-serializable object in a job property, Laravel fails before even pushing the job into the queue.)

---

# **7. Setting Up the Chaining Example**

The instructor:

1. Removes old temporary testing code
2. Prepares a fresh environment
3. Places dispatching logic inside a controller-like location (temporary for testing)
4. Prepares to show live chaining in the next lesson

At this point, the instructor explains how to use:

```php
JobA::dispatch()->chain([
    new JobB(),
    new JobC(),
]);
```

or the preferred:

```php
Bus::chain([...])->dispatch();
```

But full implementation is shown in **Job Chaining Part 2**.


### Extra


Great question â€” and this is **exactly the heart of how job chaining works**.
Laravel handles chained jobs **differently** from normal jobs to guarantee correct order even if you have **one worker** or **many workers**.

Below is the clearest possible explanation.

---

# âœ… **Short Answer (High-Level)**

### **If you have ONE worker**

* That worker processes Job 1
* When Job 1 finishes â†’ Laravel pushes Job 2 to the queue
* Same worker eventually picks Job 2
* Then Job 3, etc.
* Everything runs one after another, always in order.

### **If you have MANY workers**

* Worker #1 runs Job 1
* When Job 1 finishes â†’ Laravel queues Job 2
* ANY available worker may pick Job 2
* Job 3 is only pushed AFTER Job 2 finishes
* So order is **guaranteed**, no matter which worker executes each job.

**Important:**
Only ONE job in the chain exists at a time.
A later job is never queued until the previous job has finished successfully.

---

# ğŸ§  **Detailed Explanation: How Laravel Actually Handles Job Chains**

Letâ€™s say you chain 3 jobs:

```php
Bus::chain([
    new ProcessOriginal($file),
    new GenerateThumbnails($file),
    new SendEmail($file),
])->dispatch();
```

---

# â­ Step-by-step Lifecycle of a Chained Job

## **1. Laravel DOES NOT put all jobs into the queue at once**

Instead:

### Laravel only pushes the **FIRST** job to the queue.

```
[Queue] â†’ ProcessOriginal   (only this job exists)
```

Jobs 2 and 3 are stored *inside serialized metadata* of Job 1 â€” not inside the queue.

---

## **2. Worker picks Job 1**

If you have:

* 1 worker â†’ that worker runs it
* 10 workers â†’ any of them runs it

---

## **3. When Job 1 finishes**

Laravel:

1. Loads chain metadata from Job 1
2. Removes Job 1 from the chain
3. Pushes **only Job 2** into the queue

```
[Queue] â†’ GenerateThumbnails
```

Not Job 3. Only the next one.

---

## **4. Worker picks Job 2**

Again:

* Could be the same worker
* Could be another worker
* Could even be on another server (Horizion, multi-server queue system)

---

## **5. When Job 2 finishes**

Laravel:

1. Loads chain metadata
2. Pushes **Job 3**

```
[Queue] â†’ SendEmail
```

---

## **6. Job 3 runs**

Once finished:

* Chain ends
* No more jobs are queued

---

# ğŸ¯ **Key Point: Only ONE job at a time is ever in the queue**

This is how Laravel guarantees order:

* Job 2 does not exist until Job 1 completes
* Job 3 does not exist until Job 2 completes
* Worker count does NOT matter

This makes chaining 100% deterministic.

---

# ğŸ› ï¸ Example With Workers

## **Scenario A: One Worker**

```
Worker #1 picks Job 1 â†’ completes
Worker #1 picks Job 2 â†’ completes
Worker #1 picks Job 3 â†’ completes
```

Sequential execution.

---

## **Scenario B: Two Workers**

```
Worker #1 picks Job 1 â†’ completes
â†’ Job 2 is queued
Worker #2 picks Job 2 â†’ completes
â†’ Job 3 is queued
Worker #1 picks Job 3 â†’ completes
```

Still sequential **because job order is enforced by queue insertion, not by workers**.

---

## **Scenario C: Five Workers**

You still get:

* Job 1 runs first
* Job 2 runs second
* Job 3 runs last

Different workers may handle different jobs, but **nothing breaks order**.

---

# â— What happens if a job fails?

* The chain **stops completely**
* No other jobs are queued
* You can define `failed()` handler
* Retries work normally (Job retries still respect chain order)

---

# ğŸ”¥ Summary (Important to Remember)

### âœ” Chain order is preserved because:

**Laravel queues only ONE job at a time from the chain.**

### âœ” More workers DO NOT break order

Because later jobs are not even queued until earlier jobs finish.

### âœ” Workers may change between steps

But the sequence never does.

### âœ” Perfect for:

* Generating multiple image sizes
* Multi-step imports
* Video encoding pipelines
* Any operation where step B depends on step A